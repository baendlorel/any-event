class EventBus {
  constructor() {
    let t = '[TS-Event-Hub]';
    (this.logger = {
      on: !0,
      log: (...e) => this.logger.on && console.log(t, ...e),
      warn: (...e) => this.logger.on && console.warn(t, ...e),
      error: (...e) => this.logger.on && console.error(t, ...e),
      throw: (e) => {
        throw new Error(t + ' ' + e);
      },
    }),
      (this.eventMap = new Map());
  }
  isArrowFunction(t) {
    'function' != typeof t &&
      this.logger.throw(
        '给的参数不是函数，无法判断是否为箭头函数。The parameter provided is not a function, cannot tell it is whether an arrow function'
      );
    try {
      return (
        new new Proxy(t, {
          construct(e, t) {
            return {};
          },
        })(),
        !1
      );
    } catch (e) {
      return e instanceof TypeError && e.message && e.message.includes('is not a constructor')
        ? !0
        : (this.logger.error('isArrowFunction', 'fn:', t),
          this.logger.throw('isArrowFunction判断发生未知错误'),
          !1);
    }
  }
  getConfigs(e) {
    var t,
      n,
      r = [];
    for (t of this.eventMap.keys())
      t.includes('.*')
        ? ((n = t.replace(/\.\*\./g, '.[^.]+.').replace(/\.\*$/g, '.[^.]+')),
          (n = new RegExp(n, 'g')),
          (n = e.match(n)) && n[0] === e && ((n = this.eventMap.get(t)), r.push(n)))
        : t === e && ((n = this.eventMap.get(t)), r.push(n));
    return r;
  }
  getExactConfigs(e) {
    return this.eventMap.get(e);
  }
  register(e, t, n) {
    'string' != typeof e && this.logger.throw('eventName必须是string。eventName must be a string'),
      'function' != typeof t &&
        this.logger.throw('handler必须是function。handler must be a function'),
      'number' != typeof n &&
        void 0 !== n &&
        this.logger.throw(
          'capacity必须是number或undefined。capacity must be a number or undefined'
        ),
      e.match(/[^.]\*/g) &&
        this.logger.throw(
          "事件名称不允许使用前面不带.的*号，比如“*evt”和“evt*”。eventName cannot use '*' not come after '.'. e.g.'*evt' and 'evt*'"
        );
    let r = this.eventMap.get(e),
      i = (void 0 === r && ((r = new Set()), this.eventMap.set(e, r)), void 0);
    for (var o of r.values())
      if (o.handler === t) {
        i = o;
        break;
      }
    void 0 !== i
      ? (this.logger.warn(
          `这个事件名下已经有同一个函数了，将只更新执行次数而不重复注册。 This handler function is already existed under the event '${e}', it will not be registered again and only the capacity will be updated`
        ),
        (i.capacity = n))
      : r.add({
          name: e,
          handler: t,
          capacity: n,
          isArrowFunctionHandler: this.isArrowFunction(t),
        });
  }
  on(e, t, n) {
    this.register(e, t, n);
  }
  once(e, t) {
    this.register(e, t, 1);
  }
  off(e, t) {
    'string' != typeof e && this.logger.throw('eventName必须是string。eventName must be a string'),
      'function' != typeof t &&
        void 0 !== t &&
        this.logger.throw(
          'handler必须是function或undefined。handler must be a function or undefined'
        );
    var n = this.getExactConfigs(e);
    if (void 0 === n)
      this.logger.warn(`事件名'${e}'没有匹配的事件集合。Event '${e}' has no matched config sets.`);
    else if (t) {
      for (var r of n.values())
        if (r.handler === t) {
          n.delete(r);
          break;
        }
      0 === n.size && this.eventMap.delete(e);
    } else this.eventMap.delete(e);
  }
  clear() {
    this.logger.log(
      `清空所有事件，共${this.eventMap.size}个。Clear all ${this.eventMap.size} events`
    ),
      this.eventMap.clear();
  }
  emit(e, ...t) {
    this.emitWithThisArg(e, void 0, ...t);
  }
  emitWithThisArg(r, t, ...i) {
    'string' != typeof r && this.logger.throw('eventName必须是string。eventName must be a string'),
      r.includes('*') &&
        this.logger.throw(
          '触发用的eventName不能包含*。eventName used in emit function cannot include *'
        );
    let o = t
      ? (e) => {
          e.isArrowFunctionHandler &&
            this.logger.warn(
              '使用箭头函数时指定thisArgs可能无法达到预期效果！Appoint thisArg while using arrow function might not meet your expectaions!'
            ),
            e.handler.call(t, ...i);
        }
      : (e) => e.handler(...i);
    var e,
      n = this.getConfigs(r);
    0 === n.length &&
      this.logger.warn(`事件名'${r}'没有匹配的事件集合。Event '${r}' has no matched config sets.`);
    for (e of n)
      e.forEach((e, t, n) => {
        this.logger.log(`以${r}触发了${e.name}。${r} triggered ${e.name}.`, ...i),
          o(e),
          void 0 !== e.capacity && (e.capacity--, e.capacity <= 0) && n.delete(e),
          0 === n.size && this.eventMap.delete(e.name);
      });
  }
  turnOnLog() {
    this.logger.on = !0;
  }
  turnOffLog() {
    this.logger.on = !1;
  }
  logEventMaps(e) {
    e
      ? console.log(
          '[TS-Event-Hub]',
          `所有事件映射展示如下。All events lies below 
`,
          this.eventMap
        )
      : this.logger.log(
          `所有事件映射展示如下。All events lies below 
`,
          this.eventMap
        );
  }
}
